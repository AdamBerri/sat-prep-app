#!/usr/bin/env node
/**
 * Transform SAT Generator Questions → Big App Import Format
 *
 * Reads questions from the SAT Generator output directory, transforms them
 * to the Big App import format, shuffles answers, and outputs a JSON file
 * ready for import.
 *
 * Usage:
 *   node scripts/transform-generator-questions.mjs [--passing-only] [--output FILE]
 *
 * Options:
 *   --passing-only   Only include questions that passed evaluation (score >= 3.5)
 *   --output FILE    Output file path (default: generator-import.json)
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { transformQuestion, mapPassageType, VALID_PASSAGE_TYPES } from "./transform-utils.mjs";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration
const GENERATOR_DIR =
  "/Users/berri/Desktop/initial_claude_work/SAT_Questions/sat-question-generator";
const GENERATED_DIR = path.join(GENERATOR_DIR, "generated");

const PASSING_ONLY = process.argv.includes("--passing-only");
const OUTPUT_FILE =
  process.argv.find((arg) => arg.startsWith("--output="))?.split("=")[1] ||
  (process.argv.includes("--output")
    ? process.argv[process.argv.indexOf("--output") + 1]
    : "generator-import.json");

/**
 * Find all JSON question files in the generated directory
 */
function findGeneratedQuestions() {
  const questions = [];

  function walkDir(dir) {
    if (!fs.existsSync(dir)) return;

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        walkDir(fullPath);
      } else if (entry.name.endsWith(".json") && !entry.name.includes("schema")) {
        // Filter for passing questions if requested
        if (PASSING_ONLY && !entry.name.includes("_pass_")) {
          continue;
        }

        try {
          const content = JSON.parse(fs.readFileSync(fullPath, "utf-8"));
          questions.push({ path: fullPath, data: content });
        } catch (e) {
          console.warn(`Warning: Could not parse ${fullPath}: ${e.message}`);
        }
      }
    }
  }

  walkDir(GENERATED_DIR);
  return questions;
}

// ─────────────────────────────────────────────────────────
// MAIN
// ─────────────────────────────────────────────────────────

function main() {
  console.log("╔════════════════════════════════════════════════════════════╗");
  console.log("║     Transform Generator Questions → Big App Format         ║");
  console.log("╚════════════════════════════════════════════════════════════╝");
  console.log("");
  console.log(`Generator dir: ${GENERATOR_DIR}`);
  console.log(`Passing only: ${PASSING_ONLY}`);
  console.log(`Output file: ${OUTPUT_FILE}`);
  console.log("");

  // Find all questions
  console.log("Finding generated questions...");
  const questions = findGeneratedQuestions();
  console.log(`  Found ${questions.length} questions`);
  console.log("");

  if (questions.length === 0) {
    console.log("No questions found to transform.");
    return;
  }

  // Transform questions
  console.log("Transforming questions...");
  const transformedQuestions = [];
  const passages = {};
  const stats = {
    total: 0,
    reading_writing: 0,
    math: 0,
    needsImage: 0,
    byTopic: {},
    answerDistribution: { A: 0, B: 0, C: 0, D: 0 },
  };

  for (const { data } of questions) {
    try {
      const transformed = transformQuestion(data);
      transformedQuestions.push(transformed);

      // Collect passages
      if (transformed.passageData) {
        passages[transformed.passageId] = transformed.passageData;
        delete transformed.passageData;
      }

      // Track stats
      stats.total++;
      stats[transformed.question.category]++;
      stats.answerDistribution[transformed.question.correctAnswer]++;

      const topic = data.topic?.subtopic || "unknown";
      stats.byTopic[topic] = (stats.byTopic[topic] || 0) + 1;

      if (transformed.needsImage) {
        stats.needsImage++;
      }
    } catch (e) {
      console.warn(`Warning: Failed to transform question ${data.id}: ${e.message}`);
    }
  }

  // Build export data
  const exportData = {
    exportedAt: new Date().toISOString(),
    sourceDeployment: "sat-question-generator",
    summary: {
      totalQuestions: stats.total,
      totalPassages: Object.keys(passages).length,
      totalImages: 0, // Images will be generated by Big App
      byCategory: {
        reading_writing: stats.reading_writing,
        math: stats.math,
      },
      questionsNeedingImages: stats.needsImage,
    },
    images: {}, // No images to upload - Big App will generate them
    passages,
    questions: transformedQuestions,
  };

  // Write output
  console.log("");
  console.log(`Writing ${OUTPUT_FILE}...`);
  fs.writeFileSync(OUTPUT_FILE, JSON.stringify(exportData, null, 2));

  // Print summary
  console.log("");
  console.log("═══════════════════════════════════════════════════════════════");
  console.log("                          SUMMARY                              ");
  console.log("═══════════════════════════════════════════════════════════════");
  console.log(`  Total questions: ${stats.total}`);
  console.log(`  Reading/Writing: ${stats.reading_writing}`);
  console.log(`  Math: ${stats.math}`);
  console.log(`  Need images: ${stats.needsImage}`);
  console.log(`  Passages: ${Object.keys(passages).length}`);
  console.log("");
  console.log("Answer distribution (after shuffle):");
  console.log(`  A: ${stats.answerDistribution.A} (${((stats.answerDistribution.A / stats.total) * 100).toFixed(1)}%)`);
  console.log(`  B: ${stats.answerDistribution.B} (${((stats.answerDistribution.B / stats.total) * 100).toFixed(1)}%)`);
  console.log(`  C: ${stats.answerDistribution.C} (${((stats.answerDistribution.C / stats.total) * 100).toFixed(1)}%)`);
  console.log(`  D: ${stats.answerDistribution.D} (${((stats.answerDistribution.D / stats.total) * 100).toFixed(1)}%)`);
  console.log("");
  console.log("Questions by topic:");
  const sortedTopics = Object.entries(stats.byTopic).sort((a, b) => b[1] - a[1]);
  for (const [topic, count] of sortedTopics.slice(0, 10)) {
    console.log(`  ${topic}: ${count}`);
  }
  if (sortedTopics.length > 10) {
    console.log(`  ... and ${sortedTopics.length - 10} more topics`);
  }
  console.log("");
  console.log(`Output written to: ${OUTPUT_FILE}`);
  console.log("");
  console.log("Next steps:");
  console.log("  1. Review the output file");
  console.log("  2. Run: npm run import:questions generator-import.json");
  console.log("  3. Generate images: npx convex run graphImagePipeline:generateGraphImages");
}

main();
